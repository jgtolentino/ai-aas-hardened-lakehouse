name: Policy Gate
on:
  pull_request_target:
    types: [opened, synchronize, edited, ready_for_review, labeled, unlabeled, reopened]
permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: policy-gate-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  enforce:
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate PR policy
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const number = pr.number;
            const body = (pr.body || "").trim();
            const labels = (pr.labels || []).map(l => (l.name || "").toLowerCase());
            const isFeat = labels.includes("type/feat");
            const isXL   = labels.includes("size/xl");

            // --- Parse risk from PR body (e.g., "Risk:  low")
            let risk = null;
            const riskRe = /(^|\n)\s*risk:\s*([a-z]+)/i;
            const mRisk = body.match(riskRe);
            if (mRisk) risk = (mRisk[2] || "").toLowerCase();

            // --- Require the acceptance checkbox checked for feature PRs
            // Matches "- [x] Acceptance checks included" (case-insensitive, allows spaces)
            const acceptanceChecked = /- \[[xX]\]\s*Acceptance\s+checks\s+included/i.test(body);

            // Collect violations
            const violations = [];

            // Rule 1: size/XL must be explicitly risk: low
            if (isXL && risk !== "low") {
              violations.push("**size/XL** PR must declare \`risk: low\` in the PR body. Update the \`Risk:\` line to \`low\` or split the PR.");
            }

            // Rule 2: type/feat must include checked acceptance checkbox
            if (isFeat && !acceptanceChecked) {
              violations.push("**type/feat** PR must have the **\`- [x] Acceptance checks included\`** checkbox checked in the PR body.");
            }

            // Optional: gentle nudge if no checkboxes at all (treat as missing checklist)
            const anyChecked = /- \[[xX]\]/.test(body);
            if (isFeat && !anyChecked) {
              violations.push("Feature PR appears to have **no checklist checked**. Tick the relevant boxes from the PR template.");
            }

            // Post (or update) a sticky comment with results
            const marker = "<!-- policy-gate -->";
            const header = "### ðŸš« Policy Gate\n" + marker;
            const okHeader = "### âœ… Policy Gate\n" + marker;

            const { data: comments } = await github.rest.issues.listComments({
              ...context.repo, issue_number: number, per_page: 100
            });
            const prev = comments.find(c => (c.user?.type === "Bot" || c.user?.login?.includes("[bot]")) && (c.body||"").includes(marker));

            if (violations.length) {
              const bodyText = \`\${header}\n\nThis PR violates required policies:\n\n\${violations.map(v => \`- \${v}\`).join("\n")}\n\n**Fix and push** to re-run checks.\`;
              if (prev) {
                await github.rest.issues.updateComment({ ...context.repo, comment_id: prev.id, body: bodyText });
              } else {
                await github.rest.issues.createComment({ ...context.repo, issue_number: number, body: bodyText });
              }
              core.setFailed("Policy violations detected.");
            } else {
              const okText = \`\${okHeader}\n\nAll policy checks passed.\`;
              if (prev) {
                await github.rest.issues.updateComment({ ...context.repo, comment_id: prev.id, body: okText });
              } else {
                await github.rest.issues.createComment({ ...context.repo, issue_number: number, body: okText });
              }
            }