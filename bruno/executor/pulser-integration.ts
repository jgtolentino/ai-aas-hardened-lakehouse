import { brunoExecutor } from './bruno-executor';
import type { BrunoJob, BrunoResult } from './types';

export interface PulserJobRequest {
  jobId: string;
  agentId: string;
  agentType: string;
  capability: string;
  payload: any;
  permissions: string[];
  context: {
    requestId?: string;
    userId?: string;
    source?: string;
  };
}

export class PulserBrunoIntegration {
  /**
   * Converts a Pulser job request to a Bruno job
   */
  static convertPulserJob(request: PulserJobRequest): BrunoJob {
    // Map agent types to Bruno job types
    const jobTypeMapping: Record<string, BrunoJob['type']> = {
      'executor': 'shell',
      'transformer': 'script',
      'analyzer': 'script',
      'generator': 'script',
      'validator': 'script'
    };

    const jobType = jobTypeMapping[request.agentType] || 'script';

    // Build Bruno job
    const brunoJob: BrunoJob = {
      id: `${request.jobId}-${Date.now()}`,
      type: jobType,
      permissions: request.permissions,
      metadata: {
        source: 'pulser',
        agentId: request.agentId,
        requestId: request.context.requestId,
        userId: request.context.userId
      }
    };

    // Configure job based on capability
    switch (request.capability) {
      case 'generate_prd':
        brunoJob.script = this.generatePRDScript(request.payload);
        brunoJob.permissions.push('file:write', 'template:read');
        break;

      case 'codegen_tsx':
        brunoJob.script = this.generateTSXScript(request.payload);
        brunoJob.permissions.push('file:write', 'file:read');
        break;

      case 'scan_repository':
        brunoJob.command = this.generateSecurityScanCommand(request.payload);
        brunoJob.permissions.push('file:read', 'process:execute');
        break;

      case 'generate_docs':
        brunoJob.script = this.generateDocsScript(request.payload);
        brunoJob.permissions.push('file:write', 'file:read');
        break;

      default:
        // Generic script execution
        brunoJob.script = `
          const payload = ${JSON.stringify(request.payload)};
          const capability = '${request.capability}';
          
          // Generic agent execution
          console.log(\`Executing \${capability} with payload:\`, payload);
          
          // Return mock result
          const result = {
            success: true,
            capability,
            timestamp: new Date().toISOString(),
            output: \`Executed \${capability} successfully\`
          };
          
          console.log(JSON.stringify(result));
        `;
    }

    return brunoJob;
  }

  /**
   * Execute a Pulser job through Bruno
   */
  static async executePulserJob(request: PulserJobRequest): Promise<BrunoResult> {
    const brunoJob = this.convertPulserJob(request);
    return await brunoExecutor.execute(brunoJob);
  }

  /**
   * Generate PRD creation script
   */
  private static generatePRDScript(payload: any): string {
    return `
      const fs = require('fs');
      const path = require('path');
      
      const payload = ${JSON.stringify(payload)};
      
      // PRD template
      const template = \`# Product Requirements Document: \${payload.title}
      
## Summary
\${payload.summary || 'Project summary goes here'}

## Goals
\${(payload.goals || []).map(g => '- ' + g).join('\\n')}

## Non-Goals
\${(payload.nonGoals || []).map(g => '- ' + g).join('\\n')}

## Requirements
\${(payload.requirements || []).map(r => '- ' + r).join('\\n')}

## Technical Specifications
\${payload.technicalSpecs || 'Technical specifications go here'}

## Success Criteria
\${(payload.successCriteria || []).map(c => '- ' + c).join('\\n')}

## Timeline
\${payload.timeline || 'Timeline goes here'}

---
Generated by Pulser/Bruno on \${new Date().toISOString()}
\`;
      
      // Write PRD file
      const filename = payload.out || \`PRD-\${payload.title.replace(/\\s+/g, '-')}.md\`;
      const filepath = path.join(process.cwd(), filename);
      
      fs.writeFileSync(filepath, template);
      console.log(\`PRD created: \${filepath}\`);
      
      // Return result
      console.log(JSON.stringify({
        success: true,
        file: filename,
        path: filepath
      }));
    `;
  }

  /**
   * Generate TSX component script
   */
  private static generateTSXScript(payload: any): string {
    return `
      const fs = require('fs');
      const path = require('path');
      
      const payload = ${JSON.stringify(payload)};
      
      // Component template
      const template = \`import React from 'react';
      
interface \${payload.componentName}Props {
  \${Object.entries(payload.props || {}).map(([k, v]) => \`\${k}: \${v};\`).join('\\n  ')}
}

export const \${payload.componentName}: React.FC<\${payload.componentName}Props> = (props) => {
  return (
    <div className="\${payload.componentName.toLowerCase()}">
      <h2>\${payload.componentName}</h2>
      {/* Component implementation */}
    </div>
  );
};

export default \${payload.componentName};
\`;
      
      // Write component file
      const filename = \`\${payload.componentName}.tsx\`;
      const filepath = path.join(
        process.cwd(), 
        payload.into || 'components',
        filename
      );
      
      // Ensure directory exists
      const dir = path.dirname(filepath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      
      fs.writeFileSync(filepath, template);
      console.log(\`Component created: \${filepath}\`);
      
      // Return result
      console.log(JSON.stringify({
        success: true,
        component: payload.componentName,
        file: filename,
        path: filepath
      }));
    `;
  }

  /**
   * Generate security scan command
   */
  private static generateSecurityScanCommand(payload: any): string {
    const scanners = payload.scanners || ['semgrep'];
    const outputFile = payload.output || 'security-report.json';
    
    // Build scan commands
    const commands = scanners.map((scanner: string) => {
      switch (scanner) {
        case 'semgrep':
          return `semgrep --config=auto --json -o ${outputFile} .`;
        case 'trivy':
          return `trivy fs --format json -o ${outputFile} .`;
        case 'gosec':
          return `gosec -fmt json -out ${outputFile} ./...`;
        default:
          return `echo "Unknown scanner: ${scanner}"`;
      }
    });

    return commands.join(' && ');
  }

  /**
   * Generate documentation script
   */
  private static generateDocsScript(payload: any): string {
    return `
      const fs = require('fs');
      const path = require('path');
      
      const payload = ${JSON.stringify(payload)};
      
      // Documentation template
      const template = \`# \${payload.topic}
      
\${payload.introduction || 'Introduction goes here'}

## Table of Contents
\${(payload.sections || []).map((s, i) => \`\${i + 1}. [\${s}](#\${s.toLowerCase().replace(/\\s+/g, '-')})\`).join('\\n')}

\${(payload.sections || []).map(section => \`
## \${section}

Content for \${section} goes here.
\`).join('\\n')}

---
Generated on \${new Date().toISOString()}
\`;
      
      // Write documentation file
      const filename = \`\${payload.topic.replace(/\\s+/g, '-')}.md\`;
      const filepath = path.join(
        process.cwd(),
        'docs',
        filename
      );
      
      // Ensure directory exists
      const dir = path.dirname(filepath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      
      fs.writeFileSync(filepath, template);
      console.log(\`Documentation created: \${filepath}\`);
      
      // Return result
      console.log(JSON.stringify({
        success: true,
        topic: payload.topic,
        file: filename,
        path: filepath
      }));
    `;
  }
}

// Update Pulser to use Bruno
export function updatePulserExecutor(): void {
  // This would be imported in pulser/pulser.ts
  const originalExecutor = require('../pulser/pulser').pulser.executeViaAgent;
  
  require('../pulser/pulser').pulser.executeViaAgent = async function(job: any, agent: any) {
    // Convert to Bruno job
    const pulserRequest: PulserJobRequest = {
      jobId: job.id,
      agentId: agent.config.metadata.id,
      agentType: agent.config.type,
      capability: job.request.type,
      payload: job.request.payload,
      permissions: agent.config.security.requiredPermissions || [],
      context: job.request.context || {}
    };

    // Execute via Bruno
    const result = await PulserBrunoIntegration.executePulserJob(pulserRequest);
    
    // Convert result back to Pulser format
    if (result.status === 'success') {
      try {
        const output = result.stdout ? JSON.parse(result.stdout.trim().split('\n').pop() || '{}') : {};
        return output;
      } catch {
        return { success: true, output: result.stdout };
      }
    } else {
      throw new Error(result.error || 'Execution failed');
    }
  };
}